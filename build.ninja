# This file is used to build ninja itself, but it also serves as a
# documented example.

# Note that it is an explicit non-goal of ninja to make it convenient
# to write these build files by hand.  For a real project, you'd generate
# this build file.  I was tempted to generate this file even for ninja
# itself but I figured it'd be easier to bootstrap this way.

# Most variables aren't magic at all; it's up to the rules to make use
# of them.
builddir = build
cxx = g++
#cxx = /home/evanm/projects/src/llvm/Release+Asserts/bin/clang++
cflags = -g -Wall -Wno-deprecated -fno-exceptions -fvisibility=hidden -pipe
# -rdynamic is needed for backtrace()
ldflags = -g -rdynamic

# bootstrap.sh generates a "config" file, which contains more build
# flags.
include config.ninja

# Here we declare a "rule" named "cxx", which knows how to compile
# C++ code.  The variables indented below the rule are scoped to the
# rule itself.  The "command" and "depfile" variables in rule scope
# are special; see the documentation.
rule cxx
  depfile = $out.d
  command = $cxx -MMD -MF $out.d $conf_cflags $cflags -c $in -o $out
  description = CC $out

rule ar
  command = ar crsT $out $in
  description = AR $out

rule link
  command = $cxx $conf_ldflags $ldflags -o $out $in
  description = LINK $out

# These build rules build the ".o" files from the ".cc" files,
# build "ninja.a" by linking the builddir's "ninja.o",
# and build that "ninja.o" by compiling "ninja.cc".
build $builddir/build.o: cxx src/build.cc
build $builddir/build_log.o: cxx src/build_log.cc
build $builddir/eval_env.o: cxx src/eval_env.cc
build $builddir/graph.o: cxx src/graph.cc
build $builddir/parsers.o: cxx src/parsers.cc
build $builddir/subprocess.o: cxx src/subprocess.cc
build $builddir/util.o: cxx src/util.cc
build $builddir/ninja_jumble.o: cxx src/ninja_jumble.cc
build $builddir/ninja.a: ar $builddir/build.o $builddir/build_log.o \
    $builddir/eval_env.o $builddir/graph.o $builddir/parsers.o \
    $builddir/subprocess.o $builddir/util.o $builddir/ninja_jumble.o

build $builddir/ninja.o: cxx src/ninja.cc
build ninja: link $builddir/ninja.o $builddir/ninja.a

build $builddir/build_test.o: cxx src/build_test.cc
build $builddir/build_log_test.o: cxx src/build_log_test.cc
build $builddir/ninja_test.o: cxx src/ninja_test.cc
build $builddir/parsers_test.o: cxx src/parsers_test.cc
build $builddir/subprocess_test.o: cxx src/subprocess_test.cc
build ninja_test: link $builddir/build_test.o $builddir/build_log_test.o \
    $builddir/ninja_test.o $builddir/parsers_test.o \
    $builddir/subprocess_test.o $builddir/ninja.a
  ldflags = -g -rdynamic -lgtest -lgtest_main -lpthread


# Generate a graph of the dependency tree (including the
# graph generation itself in the resulting tree).
rule gendot
  command = ./ninja -g all > $out
rule gengraph
  command = dot -Tpng $in > $out

build $builddir/graph.dot: gendot ninja build.ninja
build graph.png: gengraph $builddir/graph.dot

rule asciidoc
  command = asciidoc -a toc $in
  description = ASCIIDOC $in

build manual.html: asciidoc manual.asciidoc
build doc: phony || manual.html

# Use the built-in phony rule and an order-only dependency
# to make building "all" build all targets.
build all: phony || ninja ninja_test graph.png doc
